<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>ë‹¨ì–´ ì¹˜í™˜ê¸°</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { font-family: sans-serif; max-width: 700px; margin: 40px auto; padding: 0 20px; transition: background 0.3s, color 0.3s; }
    body.dark { background: #222; color: #ddd; }
    textarea, input { width: 100%; padding: 10px; margin-bottom: 12px; font-size: 16px; box-sizing: border-box; background: inherit; color: inherit; border: 1px solid #ccc; }
    body.dark textarea, body.dark input { border-color: #555; }
    .pair { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; margin-bottom: 8px; }
    .pair input { flex: 1 1 40%; min-width: 40%; }
    .pair button { padding: 6px 10px; font-size: 14px; }
    .controls { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 20px; }
    .copy-btn, .download-btn { position: absolute; top: 5px; right: 5px; padding: 4px 8px; font-size: 12px; cursor: pointer; }
    #output, #inputText { white-space: pre-wrap; background: #f9f9f9; font-size: 16px; line-height: 1.5; }
    body.dark #output, body.dark #inputText { background: #333; }
    #output mark { background-color: yellow; font-weight: bold; }
    .move-btn { background: #eef; border: 1px solid #88f; color: #004; }
    .delete-btn { background: #ffdddd; border: 1px solid #ff9999; color: #a00; }
    @media screen and (max-width: 500px) { .pair input { min-width:100%; flex:1 1 100%; } }
  </style>
</head>
<body>
  <h1>ğŸ”„ ë‹¨ì–´ ì¹˜í™˜ê¸°</h1>
  <button onclick="toggleDarkMode()">ğŸŒ— ë‹¤í¬ëª¨ë“œ ì „í™˜</button>

  <h3>â‘  ë¬¸ì¥ ì…ë ¥</h3>
  <div style="position:relative;">
    <textarea id="inputText" rows="5" placeholder="ë¬¸ì¥ì„ ì…ë ¥í•˜ì„¸ìš”."></textarea>
    <button class="copy-btn" onclick="copyText('inputText')">ë³µì‚¬</button>
  </div>

  <h3>â‘¡ ë‹¨ì–´ìŒ ê´€ë¦¬ (ì´ <span id="pairCount">0</span>ê°œ)</h3>
  <div id="wordPairs"></div>

  <div class="controls">
    <button onclick="addPair()">+ ë‹¨ì–´ìŒ ì¶”ê°€</button>
    <button onclick="replaceWords()">ğŸ”„ ë³€í™˜</button>
    <button class="download-btn" onclick="downloadTXT()">ğŸ“¤ TXT ì €ì¥</button>
  </div>

  <h3>â‘¢ ë³€í™˜ëœ ë¬¸ì¥</h3>
  <div style="position:relative;">
    <div id="output" style="min-height:100px; border:1px solid #ddd; padding:10px;"></div>
    <button class="copy-btn" onclick="copyText('output')">ë³µì‚¬</button>
  </div>

  <script>
    let tempPairs = [];

    document.addEventListener('DOMContentLoaded', () => {
      addPair(); addPair();
      updateCount();
    });

    function toggleDarkMode() {
      document.body.classList.toggle('dark');
    }

    function addPair(from='', to='') {
      const pair = document.createElement('div');
      pair.className = 'pair';
      pair.innerHTML = `
        <input class="from" placeholder="ì›ë³¸ ë‹¨ì–´" value="${from}">
        <input class="to" placeholder="ìˆ˜ì • ë‹¨ì–´" value="${to}">
        <span class="count">íšŸìˆ˜: 0</span>
        <button class="move-btn" onclick="moveUp(this)">â†‘</button>
        <button class="move-btn" onclick="moveDown(this)">â†“</button>
        <button class="delete-btn" onclick="deletePair(this)">âŒ</button>
      `;
      document.getElementById('wordPairs').appendChild(pair);
      pair.querySelectorAll('input').forEach(el => el.addEventListener('input', updateCount));
      updateWordCount(pair);
      updateCount();
    }

    function deletePair(btn) {
      btn.parentElement.remove();
      updateCount();
    }

    function moveUp(btn) {
      const cur = btn.parentElement, prev = cur.previousElementSibling;
      if (prev) cur.parentNode.insertBefore(cur, prev);
    }

    function moveDown(btn) {
      const cur = btn.parentElement, nxt = cur.nextElementSibling;
      if (nxt) cur.parentNode.insertBefore(nxt, cur);
    }

    function replaceWords() {
      let text = inputText.value;
      let disp = text;
      document.querySelectorAll('.pair').forEach(pair => {
        const from = pair.querySelector('.from').value.trim();
        const to = pair.querySelector('.to').value.trim();
        if (from) {
          const regex = new RegExp(from, 'gi');
          disp = disp.replace(regex, match => `<mark>${to}</mark>`);
        }
      });
      output.innerHTML = disp;
    }

    function copyText(id) {
      const el = document.getElementById(id);
      navigator.clipboard.writeText(el.value || el.innerText).then(() => {
        alert('ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!');
      });
    }

    function updateCount() {
      document.getElementById('pairCount').innerText = document.querySelectorAll('.pair').length;
    }

    // ê° ë‹¨ì–´ìŒì˜ ì¶œí˜„ íšŸìˆ˜ ì—…ë°ì´íŠ¸
    function updateWordCount(pair) {
      const from = pair.querySelector('.from').value.trim();
      if (from) {
        const count = (inputText.value.match(new RegExp(from, 'gi')) || []).length;
        pair.querySelector('.count').innerText = `íšŸìˆ˜: ${count}`;
      }
    }

    // ë‹¨ì–´ìŒì„ TXTë¡œ ì €ì¥
    function downloadTXT() {
      const pairsText = Array.from(document.querySelectorAll('.pair'))
        .map(p => {
          const f = p.querySelector('.from').value;
          const t = p.querySelector('.to').value;
          return `${f},${t}`;
        }).join('\n');

      const blob = new Blob([pairsText], { type: 'text/plain;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'ë‹¨ì–´ìŒ.txt';
      a.click();
      URL.revokeObjectURL(url);
    }

    // ë¬¸ì¥ ì…ë ¥ ì‹œ ë‹¨ì–´ì˜ ë“±ì¥ íšŸìˆ˜ ì‹¤ì‹œê°„ ë°˜ì˜
    document.getElementById('inputText').addEventListener('input', () => {
      document.querySelectorAll('.pair').forEach(pair => {
        updateWordCount(pair);
      });
    });
  </script>
</body>
</html>
